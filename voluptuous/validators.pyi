from voluptuous.error import AllInvalid as AllInvalid, AnyInvalid as AnyInvalid, BooleanInvalid as BooleanInvalid, CoerceInvalid as CoerceInvalid, ContainsInvalid as ContainsInvalid, DateInvalid as DateInvalid, DatetimeInvalid as DatetimeInvalid, DirInvalid as DirInvalid, EmailInvalid as EmailInvalid, ExactSequenceInvalid as ExactSequenceInvalid, FalseInvalid as FalseInvalid, FileInvalid as FileInvalid, InInvalid as InInvalid, Invalid as Invalid, LengthInvalid as LengthInvalid, MatchInvalid as MatchInvalid, MultipleInvalid as MultipleInvalid, NotEnoughValid as NotEnoughValid, NotInInvalid as NotInInvalid, PathInvalid as PathInvalid, RangeInvalid as RangeInvalid, TooManyValid as TooManyValid, TrueInvalid as TrueInvalid, TypeInvalid as TypeInvalid, UrlInvalid as UrlInvalid
from voluptuous.schema_builder import Schema as Schema, message as message, raises as raises
import re
import typing

basestring = str
USER_REGEX: re.Pattern
DOMAIN_REGEX: re.Pattern

def truth(f: typing.Callable) -> typing.Callable: ...

class Coerce:
    type: typing.Callable
    msg: str
    type_name: str
    def __init__(self, type: typing.Callable, msg: str | None = None) -> None: ...
    def __call__(self, v): ...

def IsTrue(v): ...
def IsFalse(v): ...
def Boolean(v): ...

class _WithSubValidators:
    validators: typing.List[Schema]
    msg: str
    required: bool
    discriminant: typing.Callable[[typing.Any, typing.List[Schema]], typing.List[Schema]] | None
    def __init__(self, *validators, **kwargs) -> None: ...
    schema: Schema
    def __voluptuous_compile__(self, schema): ...
    def __call__(self, v): ...
    def _exec(self, funcs: typing.List[Schema], v, path: typing.List[str] | None = None): ...

class Any(_WithSubValidators): ...
Or = Any

class Union(_WithSubValidators): ...
Switch = Union

class All(_WithSubValidators): ...
And = All

class Match:
    pattern: re.Pattern
    msg: str | None
    def __init__(self, pattern: re.Pattern | str, msg: str | None = None) -> None: ...
    def __call__(self, v): ...

class Replace:
    pattern: re.Pattern
    substitution: str
    msg: str | None
    def __init__(self, pattern: re.Pattern | str, substitution: str, msg: str | None = None) -> None: ...
    def __call__(self, v): ...

def Email(v: str): ...
def FqdnUrl(v: str): ...
def Url(v: str): ...
def IsFile(v: str): ...
def IsDir(v: str): ...
def PathExists(v: str): ...
def Maybe(validator, msg: str | None = None): ...

class Range:
    min: int | float | None
    max: int | float | None
    min_included: bool | None
    max_included: bool | None
    msg: str | None
    def __init__(self, min: int | float | None = None, max: int | float | None = None, min_included: bool = True, max_included: bool = True, msg: str | None = None) -> None: ...
    def __call__(self, v): ...

class Clamp:
    min: int | float | None
    max: int | float | None
    msg: str | None
    def __init__(self, min: int | float | None = None, max: int | float | None = None, msg: str | None = None) -> None: ...
    def __call__(self, v): ...

class Length:
    min: int | float | None
    max: int | float | None
    msg: str | None
    def __init__(self, min: int | float | None = None, max: int | float | None = None, msg: str | None = None) -> None: ...
    def __call__(self, v): ...

class Datetime:
    DEFAULT_FORMAT: str
    format: str
    msg: str | None
    def __init__(self, format: str | None = None, msg: str | None = None) -> None: ...
    def __call__(self, v): ...

class Date(Datetime):
    DEFAULT_FORMAT: str
    def __call__(self, v): ...

Container = list | tuple | set | dict

class In:
    container: Container
    msg: str | None
    def __init__(self, container: Container, msg: str | None = None) -> None: ...
    def __call__(self, v): ...

class NotIn:
    container: Container
    msg: str | None
    def __init__(self, container: Container, msg: str | None = None) -> None: ...
    def __call__(self, v): ...

class Contains:
    item: typing.Any
    msg: str | None
    def __init__(self, item, msg: str | None = None) -> None: ...
    def __call__(self, v): ...

class ExactSequence:
    validators: typing.List[Schema]
    msg: str | None
    def __init__(self, validators: typing.List[Schema], msg: str | None = None, **kwargs) -> None: ...
    def __call__(self, v): ...

class Unique:
    msg: str | None
    def __init__(self, msg: str | None = None) -> None: ...
    def __call__(self, v): ...

class Equal:
    target: typing.Any
    msg: str | None
    def __init__(self, target, msg: str | None = ...) -> None: ...
    def __call__(self, v): ...

class Unordered:
    validators: typing.List[Schema]
    msg: str | None
    def __init__(self, validators: typing.List[Schema], msg: str | None = ..., **kwargs) -> None: ...
    def __call__(self, v): ...

class Number:
    precision: int | None
    scale: int | None
    msg: str | None
    yield_decimal: bool
    def __init__(self, precision: int | None = None, scale: int | None = None, msg: str | None = None, yield_decimal: bool = False) -> None: ...
    def __call__(self, v): ...

class SomeOf(_WithSubValidators):
    min_valid: int
    max_valid: int
    def __init__(self, validators: typing.List[Schema], min_valid: int | None = None, max_valid: int | None = None, **kwargs) -> None: ...
